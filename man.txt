ğŸ§  Erros e mensagens de erro

    strerror(int errnum): Retorna uma string legÃ­vel representando o erro (errno) passado.

    gai_strerror(int errcode): Retorna uma string explicando um cÃ³digo de erro retornado por funÃ§Ãµes como getaddrinfo.

    errno: VariÃ¡vel global que armazena o cÃ³digo de erro da Ãºltima chamada de sistema com falha.

ğŸ”Œ Sockets e rede

Essas funÃ§Ãµes sÃ£o usadas para comunicaÃ§Ã£o em rede:
ğŸ§± CriaÃ§Ã£o e configuraÃ§Ã£o de sockets

    socket(int domain, int type, int protocol): Cria um socket.

    socketpair(int domain, int type, int protocol, int sv[2]): Cria um par de sockets conectados (para IPC local).

    bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen): Associa um socket a um endereÃ§o (porta e IP).

    listen(int sockfd, int backlog): Coloca o socket em modo de escuta (servidor).

    accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen): Aceita conexÃµes de entrada.

    connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen): Conecta um socket a um endereÃ§o remoto.

    setsockopt(...): Configura opÃ§Ãµes de socket (ex: SO_REUSEADDR).

    getsockname(...): ObtÃ©m o endereÃ§o do socket local.

ğŸŒ Envio e recebimento de dados

    send(int sockfd, const void *buf, size_t len, int flags): Envia dados pelo socket.

    recv(int sockfd, void *buf, size_t len, int flags): Recebe dados.

ğŸ“¡ ConversÃ£o de endereÃ§os

    htons(uint16_t): Host to network short (16 bits).

    htonl(uint32_t): Host to network long (32 bits).

    ntohs(uint16_t): Network to host short.

    ntohl(uint32_t): Network to host long.

ğŸ“– ResoluÃ§Ã£o de nomes

    getaddrinfo(...): Resolve nomes de host e serviÃ§os em endereÃ§os de socket (IPv4/IPv6).

    freeaddrinfo(...): Libera a memÃ³ria alocada por getaddrinfo.

    getprotobyname(const char *name): ObtÃ©m informaÃ§Ãµes sobre protocolos (ex: "tcp").

ğŸ“Š MultiplexaÃ§Ã£o de I/O

Usadas para monitorar mÃºltiplos descritores de arquivos/sockets ao mesmo tempo.

    select(...): Monitora mÃºltiplos FDs para leitura, escrita ou erro (usa fd_set).

    poll(...): Similar ao select, mas usa um array de estruturas pollfd.

    epoll (Linux only):

        epoll_create(int size): Cria uma instÃ¢ncia epoll.

        epoll_ctl(int epfd, int op, int fd, struct epoll_event *event): Controla o conjunto monitorado.

        epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout): Espera eventos.

    kqueue (BSD/macOS):

        kqueue(): Cria uma nova fila de eventos.

        kevent(...): Adiciona, remove ou espera eventos em um kqueue.

ğŸ“ Sistema de arquivos e diretÃ³rios

FunÃ§Ãµes para manipular arquivos e diretÃ³rios.

    chdir(const char *path): Muda o diretÃ³rio atual do processo.

    stat(const char *path, struct stat *buf): ObtÃ©m informaÃ§Ãµes sobre um arquivo.

    access(const char *pathname, int mode): Verifica permissÃµes de acesso.

    open(const char *pathname, int flags): Abre (ou cria) um arquivo.

    opendir(const char *name): Abre um diretÃ³rio para leitura.

    readdir(DIR *dirp): LÃª a prÃ³xima entrada de diretÃ³rio.

    closedir(DIR *dirp): Fecha um diretÃ³rio.

    ğŸ§­ COMO ABORDAR ESTE PROJETO â€” EM ETAPAS
âœ… 1. Entenda o objetivo final

VocÃª estÃ¡ criando um servidor web completo em C++98, que:

    Serve arquivos estÃ¡ticos

    Responde a requisiÃ§Ãµes HTTP (GET, POST, DELETE)

    Usa sockets TCP

    Usa apenas 1 poll() (ou epoll/kqueue) para lidar com mÃºltiplos clientes

    Roda CGI (como PHP ou Python)

    LÃª configuraÃ§Ãµes tipo nginx.conf

    Deve ser resiliente, nÃ£o bloquear, e manter-se disponÃ­vel

ğŸ“š 2. Materiais que vocÃª precisa estudar (por tema)
ğŸ”Œ Redes com Sockets (Sockets API)

    socket(), bind(), listen(), accept(), recv(), send(), connect()

    IP e portas

    TCP vs UDP (use TCP)

    getaddrinfo()

âš™ï¸ MultiplexaÃ§Ã£o I/O nÃ£o-bloqueante

    fcntl() com O_NONBLOCK

    poll() (fundamental)

    Como monitorar leitura e escrita com poll()

    Como evitar race conditions e CPU usage alto (poll + lÃ³gica de estado)

ğŸ“œ Parsing de HTTP

    Estrutura de uma requisiÃ§Ã£o HTTP (linha de status, headers, body)

    Respostas HTTP e seus cÃ³digos

    Como detectar fim da requisiÃ§Ã£o (Content-Length, chunked, etc.)

    MÃ©todos HTTP: GET, POST, DELETE

ğŸ—ï¸ Estrutura de Servidor

    Aceitar mÃºltiplos clientes com um sÃ³ loop (poll)

    Organizar os clientes ativos (ex: um std::map<fd, Client> com o estado de cada cliente)

    SeparaÃ§Ã£o de responsabilidades: parsing, roteamento, resposta, etc.

ğŸ—‚ï¸ Leitura de Arquivos e DiretÃ³rios

    open(), read(), write(), stat(), opendir(), readdir(), chdir()

    SeguranÃ§a: evitar acesso fora do diretÃ³rio root

âš™ï¸ ExecuÃ§Ã£o de CGI

    fork() (permitido somente para CGI)

    execve() para rodar scripts

    ComunicaÃ§Ã£o com o CGI via pipes

    Passar variÃ¡veis de ambiente como CONTENT_LENGTH, REQUEST_METHOD, PATH_INFO

ğŸ› ï¸ Parsing de arquivo de configuraÃ§Ã£o

    InspiraÃ§Ã£o no nginx.conf

    Implementar parser de arquivo customizado (sem regex)

    Trabalhar com estrutura hierÃ¡rquica: servers, locations, diretivas

ğŸ›¡ï¸ ResiliÃªncia & SeguranÃ§a

    Lidar com desconexÃµes

    Timeout de conexÃµes

    Body size limit

    Impedir traversal (../../../etc/passwd)

    Manter o servidor sempre disponÃ­vel

ğŸ§  3. Plano de aÃ§Ã£o prÃ¡tico
ğŸ“Œ Etapa 1: Servidor TCP bÃ¡sico

    Criar um socket

    TornÃ¡-lo non-blocking

    Usar poll() para aceitar conexÃµes e receber dados

    Logar as requisiÃ§Ãµes

ğŸ“Œ Etapa 2: Responder com arquivos

    Analisar mÃ©todo GET

    Servir arquivos de disco (html, css, imagens)

    Testar no navegador

ğŸ“Œ Etapa 3: Parsing HTTP completo

    Lidar com cabeÃ§alhos

    Lidar com Content-Length e chunked encoding

    Responder com os status corretos

ğŸ“Œ Etapa 4: POST e upload

    Interpretar body corretamente

    Salvar arquivos no sistema de arquivos

ğŸ“Œ Etapa 5: DELETE e rota

    LÃ³gica para deletar arquivos se permitido

ğŸ“Œ Etapa 6: Parsing do arquivo de configuraÃ§Ã£o

    Criar mini-parser tipo nginx

    Gerar estrutura de objetos: Server, Route, etc.

ğŸ“Œ Etapa 7: CGI

    Detectar extensÃµes (.php, .py)

    Usar fork() + execve() + pipe

    Passar variÃ¡veis de ambiente e argumentos

ğŸ“Œ Etapa 8: Polimento final

    PÃ¡ginas de erro

    Upload com limites

    VÃ¡rias portas e servidores virtuais

    Testes de carga com ferramentas como ab, curl, ou scripts em Python

ğŸ§° Ferramentas de apoio

    telnet ou netcat: para testar manualmente

    curl: para testar mÃ©todos HTTP e upload

    Navegador: para testar comportamento real

    Ferramentas como valgrind: para detectar vazamentos

ğŸ§— Dica final

Esse projeto nÃ£o Ã© sÃ³ para escrever um servidor â€” ele ensina como funciona a internet por dentro. Aprenda os conceitos, faÃ§a testes pequenos por etapa, use muitos logs, e valide sempre com comportamento do nginx.

Se quiser, posso te ajudar a montar uma estrutura de arquivos e classes para o servidor e o parser de config, ou criar pequenos exercÃ­cios para estudar cada parte.

ğŸ” 1. GET â€” Obter dados

    Objetivo: Pedir dados ao servidor (ex: uma pÃ¡gina HTML, uma imagem, um ficheiro).

    NÃ£o envia corpo no pedido.

    NÃ£o altera nada no servidor.

ğŸ§ª Exemplo:

GET /index.html HTTP/1.1
Host: localhost:8080

Resposta:

HTTP/1.1 200 OK
Content-Type: text/html

<html>...</html>

ğŸ“ 2. POST â€” Enviar dados

    Objetivo: Enviar dados do cliente para o servidor (formulÃ¡rios, uploads, etc.)

    O corpo do pedido contÃ©m os dados (ex: um ficheiro, JSON, texto).

    Pode criar ou modificar recursos no servidor.

ğŸ§ª Exemplo (upload de ficheiro):

POST /upload HTTP/1.1
Host: localhost:8080
Content-Type: text/plain
Content-Length: 17

OlÃ¡, ficheiro novo!

Resposta:

HTTP/1.1 201 Created

âŒ 3. DELETE â€” Apagar recurso

    Objetivo: Pedir ao servidor para apagar um ficheiro ou recurso.

    Pode ter ou nÃ£o corpo, mas normalmente sÃ³ indica o que apagar na URL.

ğŸ§ª Exemplo:

DELETE /files/teste.txt HTTP/1.1
Host: localhost:8080

Resposta:

HTTP/1.1 200 OK
Content-Type: text/plain

Ficheiro apagado com sucesso.

    âš ï¸ Em muitos servidores (e no teu webserv), precisas configurar permissÃµes para permitir DELETE.

////////////////////////////////////////////////////////

Configuration file:

--> Choose port and host (host | port)
--> Server name (serverName)
-->  The first server for a host:port will be the default for this host:port (meaning it will respond to all requests that do not belong to another server).
        --> Se houver mais servidores sem server_name a ouvir da mesma port, o nome do server vai ser igual ao primeiro

--> Set up default error pages;
--> Max body size


--> LOCATIONS <--

--> Set accepted methods
--> Define HTTP redirect
--> Define a directory or file where the requested file should be located (e.g., if url /kapouet is rooted to /tmp/www, url /kapouet/pouic/toto/pouet is /tmp/www/pouic/toto/pouet)
        --> Set up the root
--> Enable or disable directory listing.
        --> Autoindex (on | off)
--> Set a default file to serve when the request is for a directory.
        --> Directory in front of the location
--> Execute CGI based on certain file extension (for example .php).
        --> cgiExtension and cgiPath;
--> Make it work with POST and GET (Jorge)


